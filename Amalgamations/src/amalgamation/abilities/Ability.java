
package amalgamation.abilities;

import amalgamation.Amalgamation;

import java.io.Serializable;

import java.util.ArrayList;
import java.util.Objects;
import java.util.Random;

/**
 * The Ability that an Amalgamation can use in combat
 * 
 * @author Jordan LaRiccia, Caleb Rush
 */
public class Ability implements Serializable {
    private final String name;
    private final String description;
    private final int cooldown;
    private int currentCooldown;
    private final int accuracy;
    private final int level;
    private final StatModifier[] modifiers;
    
     /**
      * Constructs a new Ability object
      * @param name the name of the ability
      * @param cooldown the cooldown value of the ability
      * @param accuracy the accuracy value of the ability
      * @param level the level when this move is learned
      * @param modifiers the list of stat modifiers for the ability
      * @param description a basic description of the Ability to be displayed
      *                     to the user. This can use endline characters.
      */
    public Ability(String name, int cooldown, int accuracy, int level, 
            StatModifier[] modifiers, String description){
        this.name = name;
        this.accuracy = accuracy;
        this.cooldown = cooldown;
        this.level = level;
        this.modifiers = modifiers;
        this.description = description;
    }
    
    /**
     * Calls statAdjuster for the list of stat modifiers for the move
     * 
     * @param player the current user/Amalgamation of the ability
     * @param opponent the other Amalgamation that is opposing the current
     * Amalgamation
     * @return the script generated by the move being enacted.
     * @throws IllegalStateException if the isUsable method returns false when
     *         this method is called
     */
    public String[] affect(Amalgamation player, Amalgamation opponent) throws
            IllegalStateException {
        if (!isUsable())
            throw new IllegalStateException(String.format(
                    "%s cannot be used! It must cool down for %d more turns!", 
                    name, currentCooldown));
        
        // Set the currentCooldown.
        currentCooldown = cooldown;
        
        ArrayList<String> script = new ArrayList();
        script.add(player.getName() + " used " + name + " .");
        
        // Determine if the Ability will hit or miss.
        if (miss(player.getLuckVariance()))
            script.add(String.format("%s missed!", player.getName()));
        else {
            // Perform the attack.
            if (this instanceof Attack)
                script.add(((Attack)this).attack(player, opponent));
        
            // Perform stat modifications.
            for (StatModifier m : modifiers) 
                script.add(m.statAdjuster(player, opponent));
        }
        
        return script.toArray(new String[0]);
    }
    
    @Override 
    public boolean equals(Object object) {
        return object instanceof Ability && 
                ((Ability)object).getName().equals(name);
    }

    @Override
    public int hashCode() {
        int hash = 3;
        hash = 89 * hash + Objects.hashCode(this.name);
        return hash;
    }
    
    /**
     * Gets the accuracy value  
     * @return accuracy
     */
    public int getAccuracy(){
        return accuracy;
    }
    
    /**
     * Retrieves the cooldown for the Ability.
     * 
     * @return the cooldown for the Ability
     */
    public int getCooldown() {
        return cooldown;
    }
    
    /**
     * Retrieves the current cooldown for the Ability.
     * 
     * In battle, the current cooldown is the number of turns until the Ability
     * can be used again.
     * 
     * @return the current cooldown for the Ability
     */
    public int getCurrentCooldown() {
        return currentCooldown;
    }
    
    /**
     * Returns a basic description of the Ability.
     * 
     * @return a basic description of the Ability.
     */
    public String getDescription() {
        return description;
    }
    
    /**
     * Retrieves the array of Modifiers used by this Ability.
     * 
     * @return the array of Modifiers used by this Ability
     */
    public StatModifier[] getModifiers() {
        return modifiers;
    }
    
    /**
     * Retrieves the level at which this Ability can be learned.
     * 
     * @return the level at which this Ability can be learned
     */
    public int getLevel() {
        return level;
    }
    
    /**
     * Gets the name of the ability 
     * @return name
     */
    public String getName(){
        return name;
    }
    
    /**
     * Indicates whether or not the Ability can currently be used.
     * 
     * The only case in which an Ability cannot be used is when the current
     * cooldown is not zero.
     * 
     * @return true if the Ability can currently be used
     */
    public boolean isUsable() {
        return currentCooldown == 0;
    }
    
    /**
     * Decrements the Ability's current cooldown by 1.
     */
    public void iterateCooldown() {
        currentCooldown--;
        if (currentCooldown < 0)
            currentCooldown = 0;
    }
    
    // Generates a random value to see if the Ability missed or hit.
    private boolean miss(double luckVariance) {
        return new Random().nextInt(100) + 1 > accuracy * luckVariance;
    }
}
